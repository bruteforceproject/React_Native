{"version":3,"file":"AliasGen.js","sourceRoot":"","sources":["../../src/generators/AliasGen.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n * @format\n */\n\n'use strict';\n\nimport type {\n  NativeModuleBaseTypeAnnotation,\n  NativeModuleObjectTypeAnnotation,\n  NamedShape,\n  Nullable,\n} from '@react-native/codegen/lib/CodegenSchema';\nimport {AliasMap, getAliasCppName} from './AliasManaging';\nimport {CppCodegenOptions, translateField} from './ObjectTypes';\n\nfunction translateObjectMembersDefinition(\n  type: NativeModuleObjectTypeAnnotation,\n  aliases: AliasMap,\n  baseAliasName: string,\n  prefix: string,\n  options: CppCodegenOptions,\n) {\n  return type.properties\n    .map((prop: NamedShape<Nullable<NativeModuleBaseTypeAnnotation>>) => {\n      let propType = prop.typeAnnotation;\n      if (prop.optional && propType.type !== 'NullableTypeAnnotation') {\n        propType = {type: 'NullableTypeAnnotation', typeAnnotation: propType};\n      }\n      return `${prefix}${translateField(\n        propType,\n        aliases,\n        `${baseAliasName}_${prop.name}`,\n        options,\n      )} ${prop.name};`;\n    })\n    .join('\\n');\n}\n\nfunction translateObjectMembersReflection(\n  type: NativeModuleObjectTypeAnnotation,\n  aliasCppName: string,\n  prefix: string,\n) {\n  return type.properties\n    .map((prop: NamedShape<Nullable<NativeModuleBaseTypeAnnotation>>) => {\n      return `${prefix}{L\"${prop.name}\", &${aliasCppName}::${prop.name}},`;\n    })\n    .join('\\n');\n}\n\nexport function createAliasMap(nativeModuleAliases: {\n  [name: string]: NativeModuleObjectTypeAnnotation;\n}): AliasMap {\n  const aliases: AliasMap = {types: {}, jobs: Object.keys(nativeModuleAliases)};\n  for (const aliasName of aliases.jobs) {\n    aliases.types[aliasName] = nativeModuleAliases[aliasName];\n  }\n  return aliases;\n}\n\ninterface AliasCode {\n  definition: string;\n  reflection: string;\n}\n\ninterface AliasCodeMap {\n  [name: string]: AliasCode;\n}\n\nfunction generateSingleAlias(\n  aliases: AliasMap,\n  aliasName: string,\n  aliasCode: AliasCodeMap,\n  options: CppCodegenOptions,\n): void {\n  const aliasCppName = getAliasCppName(aliasName);\n  const aliasType = <NativeModuleObjectTypeAnnotation>aliases.types[aliasName];\n  const definition = `\nstruct ${aliasCppName} {\n${translateObjectMembersDefinition(\n  aliasType,\n  aliases,\n  aliasName,\n  '    ',\n  options,\n)}\n};\n`;\n  const reflection = `\ninline winrt::Microsoft::ReactNative::FieldMap GetStructInfo(${aliasCppName}*) noexcept {\n    winrt::Microsoft::ReactNative::FieldMap fieldMap {\n${translateObjectMembersReflection(aliasType, aliasCppName, '        ')}\n    };\n    return fieldMap;\n}\n`;\n  aliasCode[aliasName] = {definition, reflection};\n}\n\nfunction generateNestedAliasesInCorrectOrder(\n  aliases: AliasMap,\n  aliasCode: AliasCodeMap,\n  aliasOrder: string[],\n  options: CppCodegenOptions,\n): void {\n  // retrieve and clean all ungenerated aliases\n  const jobs = aliases.jobs;\n  aliases.jobs = [];\n\n  // generate each one in its found order\n  for (const aliasName of jobs) {\n    // generate a new struct and all fields will be examined\n    // new anonymous objects could be found\n    // they will be stored in aliases.jobs\n    generateSingleAlias(aliases, aliasName, aliasCode, options);\n    // nested C++ structs must be put before the current C++ struct\n    // as they will be used in the current C++ struct\n    // the order will be perfectly and easily ensured by doing this recursively\n    generateNestedAliasesInCorrectOrder(\n      aliases,\n      aliasCode,\n      aliasOrder,\n      options,\n    );\n    // all referenced C++ structs are generated\n    // put the current one following them\n    aliasOrder.push(aliasName);\n  }\n}\n\nexport function generateAliases(\n  aliases: AliasMap,\n  options: CppCodegenOptions,\n): [string, string] {\n  const aliasCode: AliasCodeMap = {};\n  const aliasOrder: string[] = [];\n  generateNestedAliasesInCorrectOrder(aliases, aliasCode, aliasOrder, options);\n\n  // aliasOrder now has the correct order of C++ struct code\n  let customTypes = '';\n  let customReflection = '';\n  for (const aliasName of aliasOrder) {\n    customTypes = `${customTypes}${aliasCode[aliasName].definition}`;\n    customReflection = `${customReflection}${aliasCode[aliasName].reflection}`;\n  }\n  return [customTypes, customReflection];\n}\n"]}